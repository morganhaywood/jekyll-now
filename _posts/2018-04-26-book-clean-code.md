---
layout: post
title: Book&#58; Clean Code
tags:
  - learnings
  - books
---

This is a collation of my thoughts on the _Clean Code_ book. It is aggregated from my weekly reviews.

The forward to this book discussed the 5S principles (seiri (整理), seiton (整頓), seiso (清楚), seiketsu (清潔) and shitsuke (躾)) which made a lot of sense to me as principles for writing good code (although I found the explanation in the Japanese wikipedia was better than the one in the book :joy: 
I think Japanese concepts just make more sense in Japanese).

Chapter 1 discussed different definitions of “clean code”. The key points I took out of this were: bad code always slows you down, and begets more bad code; you can, should and have to fight to implement good code despite deadlines; 
clean code does one thing well; it is clear, easy to maintain and testable; we should aim to reduce duplication and use simple abstractions; work with your language, rather than forcing into something it’s not; write readable code; 
and always leave the code base cleaner than when you found it.

Chapter 2 discussed choosing names. The core of this was to make them as clear, intention-revealing and easy to use as possible. It also talked about avoiding encoding (including the implementation type in names), being consistent in name conventions, and giving context via classes etc in preference to prefixes. 
In short, your names should help make your code as easy to read, work with and refactor as possible.

Chapter 3 covered functions. Functions should be small, doing only one thing, use only one level of abstraction, have a descriptive name, have no side effects, and have as few arguments as possible. Long switch or if/else statements should generally be replaced by polymorphism (with the one remaining buried in a factory). It is better to have explicit outputs than output arguments, and exceptions should be used in preference to error codes. The contents of each part of a try/catch block should generally be their own method.

Chapter 4 covered comments. The main thrust was that comments should be avoided as much as possible, since they easily become out of date or misleading. It is generally better to write self-documenting code, and use comments only as a last resort (eg. to clarify working around code you cannot alter, TODOs, Javadocs for public APIs, warning of non-obvious consequences, etc).

Chapter 5 discussed formatting. It emphasised readability and consistency, especially when working as part of a team (since the whole team needs to use the same standards). I think the most interesting point it made was that code should be organised like a newspaper article, with the broad overview at the top and the nitty-gritty details at the bottom and a logical flow of information in between.

Chapter 6 talked about objects and data structures. I haven’t really thought about this topic before, so it was quite interesting. The main argument was that the two are opposites - objects expose functions which act on their data (but hide the data itself) while data structures expose their data but have no meaningful methods. This means that objects let you add new classes easily but make it difficult to add functions, and vice versa for data structures. Hybrids tend to have the worst of both worlds, so you should carefully and deliberately choose which you are going to use for each class.

Chapter 7 discussed how exceptions are preferable to returning error codes, since they allow more flexibility for when and how they are handled. It also talked about the importance of ensuring that your exceptions provide enough context, without having too many different types (which must be handled separately). It suggested encapsulating exceptional, but correct behaviour in special case objects rather than using exceptions, and why to avoid nulls where possible.

Chapter 8 discussed the use of boundaries, in particular between your system and 3rd party code. It recommended wrapping calls to 3rd party APIs (or even built-in, which may change) in your own class, so that if or when these change you only need to modify that single adapter class. This also makes testing easier, since you can easily create a test double for the adapter class which does not use the 3rd party code. Finally, it suggested testing the 3rd party API in much the same way you would your own code. This allows you to learn the new API, but later will also assist in verifying that a new version of the API is compatible with your application (or what you need to change).

Chapter 9 advocated that tests need to be maintained as well as the rest of your code. However, since efficiency is less of a concern, you should prioritise readability over efficiency (within reason, since your tests still need to run fast enough to be usable in a pipeline etc). It suggested writing functions within the test code on top your API when tests need to do extensive setup or other repeated calls, to make them more readable (e.g. `makePages(1,2,3,4,5)` to replace `book.addPage(1, whitePaper); book.addPage(2, whitePaper);...`). Each test should deal with only one concept, and minimise the number of asserts needed to test that concept. Finally, it discussed the need for tests to be F.I.R.S.T (fast, independent, repeatable, self-validating, and timely).  
When I looked at my tests for the tic tac toe kata, I felt that I had done fairly well with the recommendations for testing discussed above, except for the repeated calls during setup. I therefore went through and made changes based on the suggestions in Clean Code. I think that this was a good exercise, and definitely demonstrated how it can improved readability.

Chapter 10 discussed how classes should be organised. Variables should generally be public-static, then private-static, then private (since there is generally no reason to have public variables). Functions should follow a similar scheme: public first, but private methods should follow the public method that calls them rather than all being grouped at the end. Protected should generally only be used if absolutely necessary for testing.  
Classes should be as small as possible, and have only a single responsibility. Tied to this, they should also be cohesive, in that all the methods use most (if not all) of the same variables. When a class loses these properties, it should be split into two (or more) classes. Having many seperate, small classes means that each class will only have **one** reason to change. Thus changes won't break existing code (or as little exiting code as possible). This conforms to the open-closed principle: classes should be open for extension but closed for modification. In general, you should therefore be dependent upon interfaces rather than concrete classes (i.e. use the dependency inversion principle).

Chapter 11 examined systems. It explained the importance of having a globally consistent strategy for set up and instantiation. E.g. put all setup into main, use abstract factories, or use dependency injection. This is in contrast to e.g. using lazy initiation, where new objects are created on the fly when they become necessary. Separating these concerns allows for better incremental growth and easier testing. One way to get around many of these issues is to use a minimally-invasive aspect-oriented framework, which as the name suggests will handle certain concerns by aspect (e.g. instantiation). On a slightly different tack, this chapter also advocated doing **some** up-front design, but only the minimum necessary. In general decisions should be postponed until the last possible moment, so that they are made with the most possible information. Finally, architecture should not be invasive; it should help your code be clean, not take it over.

Chapter 12 discusses how simple, well-written code tends to be clean naturally. Specifically, if you follow the four rules of simple design then it almost unavoidable to end up with clean code. Rule 1 is to run all the tests, and easily testable code tends to be clean. A good test suite also makes refactoring easier, which leads to cleaner code. Rule 2 is to have no (or minimal) duplication, which removes work, risk and complexity. Template methods are a good way to do this; you implement all the common parts (sub-methods), and leave the variable section (sub-method) abstract, then sub-class it with concrete implementations. Rule 3 (express the intent of the programmer) naturally leads to meaningful names, small classes and standard nomenclature. Finally there is rule 4: minimise the number of classes and methods. It must be kept in mind that the rules are ordered, and therefore this is the lowest priority. It is bad to have too many tiny classes, but at the same time it is worse to have one huge one.

Chapter 13 covers (some of) concurrency. It is a very long chapter, and expected from the complexity of the subject. Concurrency decouples the **what** from the **when**. This can improve structure and throughput, but also introduces complexity which can do more harm than good. There are four basic principles to keep in mind when working with concurrency: the single responsibility principle (concurrency is one responsibility); to limit the scope of data; to use copies of data; and that threads should be as independent as possible. Other things to keep in mind include: understand your language's standard library an work with it; learn common execution models and how to solve the problems inherent in them (e.g. producer-consumer, readers-writers, dining philosophers); only have one synchronised method per class (use a client-based lock, server-based lock, or adapted server to achieve this if necessary); keep synchronised sections as small as possible, since these are bottlenecks; shutting down is very difficult, so if it's necessary then plan early; treat any unusual bugs or failures (especially sporadic ones) as threading issues; run your tests with many threads, on many OS and in many configurations (e.g. using jiggling); and keep your threaded and non-threaded code seperate and pluggable so that each can be tested independently of the other.

Chapter 14 is a case study showing how successive refinement can lead from a first draft of a program to a cleanly-written program. Rough drafts are necessary, but once you have enough information to understand what the design **should** be, but before your program gets too big to fix, you should stop adding features and take the time to clean what you have done. To do this you need to make incremental changes that move towards a better structure, but don't break the code. Having a test suite helps with this, since you can ensure that the program still works by checking that the tests pass. In general this sort of refactoring is a long process of splitting out one thing at a time (e.g. a new class, then gradually turning that new class into an interface and sub-class structure). Sometimes there is no **perfect** solution though, and you have to compromise.
